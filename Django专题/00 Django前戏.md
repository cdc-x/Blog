# 手撸一个Web框架

## 一、Web服务的本质

### **1.1 软件开发架构**

- `C/S架构`，即客户端和服务器
- `B/S架构`，即浏览器和服务器

从本质上来说，`B/S架构` 也是 `C/S架构` ，只是使用浏览器作为了客户端。

### **1.2 浏览器的工作流程**

​		当我们在浏览器窗口输入一些小网址并进行搜索的时候，中间到底发生了哪些事情呢？站在宏观的角度去研究，从输入网址到看到我们访问的内容，整个过程中浏览器的工作流程大致可以分为这么几步：

1. 浏览器朝服务端发送请求
2. 服务端接收请求（例如：访问百度首页）
3. 服务端返回对应的响应（例如：返回百度首页的内容）
4. 浏览器接收响应并根据特定的规则渲染页面展示给用户

### **1.3 模拟一个服务端**

​		以上介绍的流程，其实就是大多数web服务的基本操作流程。我们可以通过套接字编程来编写一个服务端模拟上述过程：

```python
# server.py
import socket

server = socket.socket()
server.bind(("127.0.0.1", 8080))

server.listen(5)

while True:
    conn, addr = server.accept()
    data = conn.recv(1024)
    print(data)  # 基于网络传输的数据，所以是二进制的数据 bytes
    conn.send(b"hello, old baby ~")
    conn.close()
```

​		我们不需要再去写一个客户端，可以直接通过浏览器访问服务端的地址和端口来实现通信，因为浏览器本质上就是一个客户端。我们启动服务器，在浏览器输入 `127.0.0.1:8080` 进行访问：

​                            <img src="/static/img/Django专题/web_01.png" style="zoom:50%;" />  

操作了一把可以看到，实际的结果并没有和我们预期的一样。那么可能有的金针菇就要开始怀疑了，是不是之前介绍的那些理论是有问题的？其实并非如此，我们先来看一下服务端的情况：

<img src="/static/img/Django专题/web_02.png" style="zoom:50%;" /> 

很显然，服务端已经接收到客户端（即浏览器）发出的请求了。我们再回过头来观察一下浏览器的报错，`127.0.0.1 发送的响应无效`，这就表明我们的请求确确实实发送给了服务端，服务端也给了客户端响应，只不过在浏览器这边渲染不出来而已。

### **1.4 HTTP协议的引入**

​		既然知道了交互失败的原因，那么我们简单来推导一下问题的根源。和我们手写的客户端不同，浏览器可以充当很多服务器的客户端（如百度、腾讯视频、优酷视频......都可以通过浏览器来访问），每个服务端的写法都不相同，浏览器要是想兼容所有的服务端，必须做到以下两点之一：

- 浏览器非常牛掰，能够自动识别不用的服务端做不同的处理
- 制定一个统一的标准，如果你想让你写的服务端能够和客户端之间做正常的数据交互，就必须遵循一些规则

显然相比第一点，第二点实现起来就容易的多。而需要遵循的规则，就是我们常说的 `HTTP协议`

## 二、HTTP协议介绍